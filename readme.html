<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice 4.1.7  (Win32)">
	<META NAME="AUTHOR" CONTENT="Mike ">
	<META NAME="CREATED" CONTENT="20220909;20194854">
	<META NAME="CHANGEDBY" CONTENT="Mike ">
	<META NAME="CHANGED" CONTENT="20220930;14542829">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 2cm }
		TD P { margin-bottom: 0.21cm }
		P { margin-bottom: 0.21cm }
		H2 { margin-bottom: 0.21cm }
		H2.cjk { font-family: "SimSun" }
		H2.ctl { font-family: "Lucida Sans" }
		H5 { margin-bottom: 0.21cm }
		H5.cjk { font-family: "SimSun" }
		H5.ctl { font-family: "Lucida Sans" }
		PRE.cjk { font-family: "NSimSun", monospace }
		A:link { so-language: zxx }
		CODE.cjk { font-family: "NSimSun", monospace }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-GB" DIR="LTR">
<P>This page contains an introduction to the use of the library,
notes on its design and some profiling results and thoughts regarding
the design's performance versus other methods. The source code can be
obtained from GitHub (user: MikeBrownUK, repository:<A HREF="https://github.com/MikeBrownUK/OutputStreams">
OutputStreams</A>).</P>
<P>All code is licensed under the MIT with thanks to all I worked
with who inspired its evolution in some way (see my blog for further
details).</P>
<P>As background reading for those not terribly familiar with the
history of character representation on computers and why it often
makes developers want to cry, then a good place to start would be
<A HREF="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">Joel
Spolsky's excellent article</A> from almost twenty years ago.</P>
<H2 CLASS="western"><A NAME="OutputStreams_Contents"></A>Contents</H2>
<H5 CLASS="western"><STRONG><A HREF="#OutputStreams_GettingStarted">Getting
Started</A></STRONG></H5>
<H5 CLASS="western"><A HREF="#OutputStreams_Design">Design</A></H5>
<H5 CLASS="western"><A HREF="#OutputStreams_Profiling">Performance
Profiling</A></H5>
<H2 CLASS="western"><A NAME="OutputStreams_GettingStarted"></A>Getting
Started</H2>
<P>Here's the expurgated guide to using the OutputStreams Library.
For a better idea of the class relationships, I recommend you refer
to the design description that follows this introduction and
familiarise yourself with the source files.</P>
<H5 CLASS="western">Test Project</H5>
<P>A CMake googletest project is included in the source package. To
build the test program, you will need to download and install
googletest and set GOOGLE_TEST_PATH to point to that directory (or
you could edit all the paths in the CMakeLists.txt manually - your
choice). CMakeSettings.json is also provided for Visual Studio users
with Windows and Linux debug and release sample target
configurations.</P>
<P>To use the source with an IDE and project/makefile of your
choosing, add the <EM>OutputStreams</EM>, <EM>Utilities</EM> and
appropriate googletest directories to your include paths and all .cpp
files within <EM>OutputStreams</EM> and <EM>Utilities</EM> to your
build list alongside the two mandatory googletest source files
(<EM>gtest-all.cc</EM> and <EM>gtest_main.cc</EM>) and you should be
good to go. I recommend you look at the CMakeLists.txt file
regardless to note the compiler preprocessor defines. For Linux you
will also need to link to pthreads.</P>
<H5 CLASS="western">Using OutputStreams</H5>
<PRE CLASS="western">#include &quot;StreamAndChannelAliases.h&quot;

using namespace mbp::streams;</PRE><H5 CLASS="western">
OutputStream</H5>
<P>Create an <CODE CLASS="western">OutputStream</CODE>. The easiest
way is to use one of the predefined aliases I supply in the above
file, specifying character width for the stream:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">StreamStdOut&lt; char &gt; myStream;</PRE><P>
This creates an OutputStream of char width that writes to std::cout.
There are default construction parameters, so what you are actually
specifying above is:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">StreamStdOut&lt; char &gt; myStream( nullptr, OutputStamp::GetDefaultInstance(), &amp;GetDefaultChannelSettings() );</PRE><P>
The first parameter is not used by this stream type - it is just a
pointer to a narrow string used to carry initialisation values to the
<CODE CLASS="western">OutputTarget</CODE> the OutputStream flushes to
(for a file stream this is the name of the file to create). 
</P>
<P>The second parameter is a reference to an <CODE CLASS="western">OutputStamp</CODE>
class - these classes are used to add prefixes to entries sent to the
stream. The default is an empty singleton that does nothing but
satisfy the minimum required interface.</P>
<P>The final parameter is a pointer to a <CODE CLASS="western">StreamSetting</CODE><CODE CLASS="western"><EM>s</EM></CODE>
structure that contains initialisation values for message priority
and filtering - details later.</P>
<P>You can use this stream as you would std::cout:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">myStream &lt;&lt; &quot;some text followed by a number... &quot; &lt;&lt; 12 &lt;&lt; endl;</PRE><P>
Note the use of <CODE CLASS="western">endl</CODE> 
</P>
<P><EM>std::endl </EM>would work in this instance, but I encourage
you to use the version from my namespace as std::endl throws
exceptions on Ubuntu Linux when put into streams of char16_t and
char32_t type (at least with G++ version 9.4.0)</P>
<P>There is currently one other manipulator you should use rather
than the Standard Library version: setw. This is to ensure all code
compiles away with the Microsoft compiler when you substitute a
NullStream for your stream/channel via aliasing. If I discover others
that cause problems then I'll do my best to fix them.</P>
<H5 CLASS="western">Message Filtering</H5>
<P>Why not use std::cout or an existing type from the Standard
Library? Allow me to introduce runtime message filtering:</P>
<PRE CLASS="western">myStream &lt;&lt; Filter( 10 );
myStream &lt;&lt; DefaultPriority( 5 );</PRE><P>
Messages with a <EM>Priority</EM> less than or equal to the <EM>Filter</EM>
value are output to the final OutputTarget. Messages with a priority
higher than the <EM>Filter</EM> are discarded. Lower priority value
means higher message priority (0 = highest): after consideration I
reasoned that large numeric values are less meaningful, especially
when you aren't sure of the underlying type (currently a uint8_t).</P>
<P>You specify per-message priority using the <EM>Priority</EM>
stream manipulator:</P>
<PRE CLASS="western">myStream &lt;&lt; Priority( 11 ) &lt;&lt; &quot;This text WILL NOT APPEAR in the log as the Priority value injected is higher than the current filter (10).&quot; &lt;&lt; endl;

myStream &lt;&lt; &quot;This text WILL APPEAR as the priority has now been reset to the last set default (5) during the flush of the previous output&quot; &lt;&lt; endl;</PRE><P>
Member functions are also directly accessible in the stream object:</P>
<PRE CLASS="western">myStream.SetFilter( SettingsTypenewValue );
myStream.SetDefaultPriority( SettingsType newValue );
myStream.SetPriority( SettingsType newValue );</PRE><P>
<EM>note that SettingsType is, currently, just an alias for the
aforementioned uint8_t</EM>.</P>
<P>A final member function and corresponding manipulator control
enabling and disabling a stream's output entirely:</P>
<PRE CLASS="western">mySteam.Enable( 0 );
myStream &lt;&lt; Enable( 1 );</PRE><H5 CLASS="western">
String Conversion</H5>
<P>Optional string type conversion.</P>
<P>C++ '11 gave us two new character types and various new string
encodings but, despite these additions, when you send a non-native
string to a Standard Library stream (say a wchar_t string to a char
stream) with operator &lt;&lt; it is caught by a generic pointer
handler so your non-native (to the stream) string is almost always
output as a numeric value rather than a string of text. 
</P>
<P><EM>Additionally, conversion of many types into strings isn't
supported with char32_t and char16_t streams: Microsoft's Standard
Library implementation just produces an error relating to
std::numpunct&lt;_Elem&gt;::id whilst G++ and Linux just seem to
silently pretend that you never attempted to write a numeric to the
stream because whilst your code will compile and run you certainly
won't find that numeric in the stream buffer. </EM>
</P>
<P>I decided to catch all three character types foreign to a stream's
internal type and perform integral narrowing or widening rather than
just display a numeric pointer value as the Standard Library
currently does (when it works). This conversion is obviously not
always particularly successful when narrowing large codepoints, but I
felt it a better fit for the likely usage of this library. This
narrowing/widening behaviour is always on but I may move this to a
preprocessor define at some point - it is easy enough to achieve
yourself should you wish.</P>
<P>Secondly, I wanted to be able to convert strings into the stream's
closest UTF representation, also via pointer catching functions. This
wasn't straightforward and of course it isn't always terribly useful
considering that the underlying character type of an interface like a
terminal is often just single byte per character, so recoded strings
are still very much dependent on OutputTarget support. This feature
does perform well where files are the stream target though as I
perform the file writing in the example OutputTarget classes via
kernel OS calls.</P>
<P>Some assumptions had to be made with string conversion - not least
because of differences between platforms (wide characters having
different widths on Windows and Linux for example). 
</P>
<P>If you want to use converting streams then you need to specify
that policy in your declaration. The OutputStream type aliases
provided allow you to declare a UTF converting stream very easily:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">StreamStdOut&lt; char, ConvertingStream_t &gt; myStream;</PRE><P>
See &quot;StreamAndChannelAliases.h&quot; for the full template
syntax for the helpers.</P>
<P>OutputChannels (see next section) can also use the
ConvertingStream_t policy and OutputChannels with differing policies
can still happily share the same target OutputStream.</P>
<P><EM>Note that string conversions are only available via operator
&lt;&lt; presently - I have no intention just yet of implementing a
full basic_ostream&lt;&gt; member function interface.</EM></P>
<H5 CLASS="western">OutputChannel</H5>
<P>An OutputChannel is an additional object required if more than one
thread needs to access the OutputStream concurrently. They require
you to specify an ID, which you could use to identify separate areas
of program functionality. Each ID gets its own StreamSettings so they
don't interfere with channels using different IDs on the same
stream(s). Channels use their own buffers so can do most of their
work without any synchronisation penalty. They are only a touch more
involved to setup: they require a StreamList (just an alias for a
std::vector of pointers to the OutputStreams they are to write to) at
construction, e.g.:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">OuputChannel&lt; char &gt; myChannel( 0, { &amp;myStream }, true );</PRE><P>
Again, the above is shorthand for a constructor that is using some
default parameters. The full syntax is:</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">OutputChannel( int channelID_, std::vector&lt; BasicStream_t&lt; type &gt; * &gt; const&amp; streams_, bool isMultiThreadChannel_ = true,  OutputStamp &amp; stamp_ = OutputStamp::GetDummyStamp(), StreamSettings * initSettings_ = &amp;GetDefaultChannelSettings() )</PRE><P>
The example creates an OutputChannel with an ID of 0 - ints are used
to facilitate the use of enums for channel IDs - that attaches to the
myStream object (from earlier in the example text) and specifies that
the channel will be used by multiple threads. The final two settings
optionally specify an OutputStamp instance to use for message
prefixing and custom initial StreamSettings for the channel.</P>
<P>If you don't need multiple thread safety for a particular
OutputStream but still want the benefits of multiple channels
(independent filtering despite 'many writing to one or more') then
set the <CODE CLASS="western">isMultiThreadChannel_</CODE> parameter
in the constructor to <CODE CLASS="western">false</CODE> as this will
use an optimised buffer without the synchronisation overhead.</P>
<P>OuputChannels can be instanced on a thread's stack or by using C++
11's <CODE CLASS="western">thread_local</CODE>. If using thread_local
then prefer the second of the following examples if, like me, you
want every possible piece of assembly code optimised away when
required:</P>
<PRE CLASS="western">Option One:
thread_local OutputChannel&lt; char &gt;( construction params... );

Option Two:
TLS_OUTPUTCHANNEL&lt; char &gt;( construction params... );</PRE><P>
and of course with an <CODE CLASS="western">extern</CODE> prefix if
you want to declare in a header.</P>
<P>This is the one place I had to relent on my goal and still offer a
preprocessor define to ensure removal of all code because of the way
Microsoft's compiler (and possibly others) handle <EM>thread_local
</EM>storage. The tiny bit of TLS code generated by the compiler for
an otherwise empty object probably won't bother most people, but it
did me.</P>
<P><EM>Note that if you use the thread_local option to define your
OutputChannel at global scope then you will likely see some
unreleased memory warnings if you use the 'on exit' heap-checking
functions provided by the Windows system libs. This is because some
threads won't have destroyed their copy of the OutputChannel, and the
buffer it creates, before the main thread calls the heap check
function - you can verify that all is actually OK by hiding the
OutputChannel in a function that returns a reference to a static
thread_local.</EM></P>
<P>When an OutputChannel attaches to an OutputStream at construction,
any OutputStamp specified in that stream's constructor will no longer
be used. You <EM>must</EM> specify an OutputStamp class instance for
the channel if you want message prefixing to work with channels.
Again, this is an efficiency optimisation as all message prefixing is
performed in local buffers to minimise contention.</P>
<P>Each OutputChannel can attach to multiple OutputStreams. I have
set a somewhat arbitrary maximum of 32 individual <EM>shared</EM>
stream objects in the source - you can have as many non-shared
streams as you wish. Maximum number of OutputChannels also has a cap,
64 at present. Tweak away if needed...</P>
<P><EM>Remember that each OutputChannel ID has its own StreamSettings
structure so manipulators and member function calls used will only
effect that channel and not any other channel(s) attached to the same
OutputStream(s) -providing you give your channels different IDs.</EM></P>
<P>If you require UTF string conversion when using OutputChannels
then note that the appropriate base class template must be specified
for the channel instance.</P>
<H5 CLASS="western">Example OutputStreams</H5>
<P>All example OutputStream types (actually OutputStream_t classes
taking an OutputTarget_t template parameter) have the following
shorter aliases defined:</P>
<PRE CLASS="western">StreamFile&lt; T_ &gt;
StreamStdOut&lt; T_ &gt;
StreamConsole&lt; T_ &gt;
StreamDevStudio&lt; T_ &gt;</PRE><P>
The latter two being Windows only - you can use a StreamConsole&lt;
wchar_t &gt; for UTF16 Unicode output to your Win32 console. If your
application is a Windows GUI application then a console window will
be created alongside.</P>
<P>Streams are safe and reliable with char and wchar_t types but
char16_t and char32_t support is still somewhat flaky - mainly
because those types don't cooperate with the existing Standard
Library implementations I've tried or indeed with many system API
output functions or devices.</P>
<P>Note that if you want StreamStdOut to go to std::wcout instead of
std::cout on platforms that support it, you must have USE_STD_WCOUT
defined.</P>
<H5 CLASS="western">OutputStamp</H5>
<P>Aside from the default &quot;do nothing&quot; message prefixer
seen in the constructors above, I provide two other singleton
OutputStamp classes:</P>
<P>The first is a system date &amp; time stamp (with milliseconds
also appended):</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">StreamStdOut&lt; char &gt; myStream( nullptr, <STRONG>SystemTimeStamp&lt; char &gt;::GetInstance()</STRONG>,<STRONG> </STRONG>&amp;GetDefaultChannelSettings()<STRONG> </STRONG>);</PRE><P>
The second is intended purely as an example of an OutputStamp class
with a state, one that can write a prefix of variable length (up to a
maximum length which the OutputStamp class must make available to its
clients):</P>
<PRE CLASS="western" STYLE="margin-bottom: 0.5cm">LineStamp&lt; char &gt;::GetInstance()</PRE><P>
OutputStreams: <A HREF="#OutputStreams_Contents">Contents</A> <A HREF="#OutputStreams_Design">Design</A>
<A HREF="#OutputStreams_Profiling">Profiling</A></P>
<P><A HREF="http://www.mikebrown.co.uk/">mikebrown.co.uk homepage</A></P>
<HR>
<H2 CLASS="western"><A NAME="OutputStreams_Design"></A>Design</H2>
<P><A NAME="block-1c0864ed-50ec-409b-bbfa-7572dd31c364"></A>Here's
where I try to explain the design in a little more detail. The
easiest route is probably the one that starts with the OutputTarget
and works back to the streams and channels that write to it.</P>
<P><A NAME="block-74c0c1ba-b58b-417c-aee9-97dca4e7aa35"></A>Here's a
link to the larger version of my diagram showing the class
relationships, with apologies for any UML errors and omissions:</P>
<P><A HREF="http://mikebrown.co.uk/wp-content/uploads/2022/09/outputstreams_uml.jpg" TARGET="_blank"><FONT COLOR="#000080"><IMG SRC="http://mikebrown.co.uk/wp-content/uploads/2022/09/outputstreams_uml_small.jpg" NAME="graphics1" ALIGN=BOTTOM WIDTH=676 HEIGHT=591 BORDER=1></FONT></A>
</P>
<H5 CLASS="western"><A NAME="block-ca4a5ec9-fb48-4d5e-863a-eb818c48e868"></A>
OutputTarget &amp; OutputBuffer</H5>
<P><A HREF="http://mikebrown.co.uk/wp-content/uploads/2022/09/outputtargets_uml.jpg" TARGET="_blank"><FONT COLOR="#000080"><IMG SRC="http://mikebrown.co.uk/wp-content/uploads/2022/09/outputtargets_uml_small.jpg" NAME="graphics2" ALT="This image has an empty alt attribute; its file name is outputtargets_uml_small.jpg" ALIGN=BOTTOM WIDTH=769 HEIGHT=340 BORDER=1></FONT></A>
</P>
<P><A NAME="block-2aa7ab6b-e68c-414c-abdc-517bc5cd7fb4"></A>Whilst
OutputTarget is shown alongside other classes in the diagrams, you
will find no abstract class or interface definition within the
source.</P>
<P><A NAME="block-aac9dbfb-867a-4909-883c-c85768d485d9"></A>OutputTargets.h
and .cpp contain my example classes that satisfy the above interface
- all templates themselves so they can interface with streams and
channels of various character widths. An OutputTarget is encapsulated
within an OutputBuffer via a template parameter:</P>
<PRE CLASS="western"><A NAME="block-cb9fd122-b8ea-433c-8e08-f7819a6acdc7"></A>OutputStreams.h

...

template &lt; typename ELEM_, <STRONG>template&lt; typename &gt; typename TARGET_  &gt;</STRONG>
class OutputBuffer_t : public BasicBuffer_t&lt; ELEM_ &gt;
{
    ...
    <STRONG>TARGET_ m_outputInterface;</STRONG>
}</PRE><P>
<A NAME="block-771c37f9-1aff-46d4-8520-3dc302c606f7"></A>The
Output(...) function of the OutputTarget is called during the
OutputBuffer's implementation of sync()</P>
<PRE CLASS="western"><A NAME="block-e813a153-adad-4fdb-a1c3-ae0babf2a4e8"></A>template&lt; typename ELEM_ &gt;
class MyOutputTarget
{
    ...
    <STRONG>void Output( ELEM_ const * output_, uint32_t numCharacters_, uint32_t numBytes_ );</STRONG>
    ...
}

class OutputBuffer_t : public BasicBuffer_t&lt; ELEM_ &gt;                    
{
    ...
    virtual int sync() override
    {
        ...
        <STRONG>m_outputInterface.Output</STRONG>( base::pbase() + offset, numCharacters + stampLength, numBytes );
        ...
    }
    ...
}</PRE><P>
<A NAME="block-d53401dd-e595-4573-bbd3-748cba9b6f7c"></A>sync()
performs the filtering and prefixing legwork before forwarding the
string to the OutputTarget, presenting it with a string buffer
pointer along with character and byte counts. The buffer is
zero-terminated though the terminator is not included in either
count.</P>
<H5 CLASS="western"><A NAME="block-f66a7e6e-c972-42a9-97b7-52f7c43e194c"></A>
OutputStream</H5>
<P><A NAME="block-52e07e1f-f60d-4e7f-96f8-d7a2d3608f90"></A>The
OutputBuffer is itself a template parameter to an OutputStream - the
core template class for a stream object.</P>
<PRE CLASS="western"><A NAME="block-66cebc3b-925d-4b50-925e-4e1de2b3c0f6"></A>template&lt; typename ELEM_, template&lt; typename &gt; typename TARGET_, template&lt; typename &gt; typename STREAMBASE_ &gt;
<STRONG>class OutputStream_t</STRONG> : public STREAMBASE_&lt; ELEM_ &gt;
{
    ...

    OutputStream_t( char const * const initString_ = nullptr, OutputStamp &amp; stamp_ = OutputStamp::GetDummyStamp(), StreamSettings * initialSettings_ = &amp;GetDefaultChannelSettings() )

    ...

   <STRONG> OutputBuffer_t&lt; TARGET_, ELEM_ &gt;</STRONG> m_buffer;

    ...

};</PRE><P>
<A NAME="block-72b7119b-168c-4f89-804d-d414703a7d0c"></A>OutputStream
derives from BasicStream via the Stream or ConvertingStream template
class. These two empty classes exist purely to permit text caught by
various helper functions to be dispatched correctly. 
</P>
<P><A NAME="block-72b7119b-168c-4f89-804d-d414703a7d0c1"></A>BasicStream
extends std::basic_ostream with some virtual functions for message
filtering, a mutex and a flag used to indicate that the stream is in
multithread mode and connected to upstream OutputChannels.</P>
<P><A NAME="block-f943b550-d9d3-4c71-8459-1a6117274ff2"></A>The
OutputStream type is further aliased, in StreamAndChannelAliases.h,
into helper templates named according to their OutputTarget
destination:</P>
<PRE CLASS="western"><A NAME="block-63b7950f-f09e-48d1-9bc0-f084aaa4dc46"></A>template&lt; typename T_, template&lt; typename &gt; typename U_ = Stream_t &gt;
using StreamFile = OutputStream_t&lt; T_, OutputFile_t, U_ &gt;;</PRE><P>
<A NAME="block-f07f02ff-f838-47b8-b995-54093345eb78"></A>These are
all contained within a preprocessor block that redirects those
aliases to a NullStream template class if STREAM_OUTPUT_STRIP is
defined. NullStream is a dummy class exposing the minimum empty
function set needed to allow the compiler to optimise stream and
channel objects away in release builds along with some <EM>operator
&lt;&lt; </EM>helpers to do the same.</P>
<P><A NAME="block-f12a5fc5-6ca8-4e20-9fcd-0769a7db696f"></A>As per
the UML and the OutputStream_t constructor, an OutputStream uses
StreamSettings and an OutputStamp.</P>
<H5 CLASS="western"><A NAME="block-ad4b443c-6a6e-49bb-8e36-a9a7c995c38b"></A>
StreamSettings</H5>
<P><A NAME="block-07b2700b-b8d3-47c2-9262-1bf0c3135db5"></A>The
StreamSettings structure holds the current runtime filtering flags
for the stream. These are: Enable, Priority, Default Priority, and
Filter. All flags are atomic as this structure is also used by
OutputChannels which must be thread-safe.</P>
<P><A NAME="block-07a617dd-e667-4500-b5ad-acaaa2cbff6b"></A>Enable is
a simple on/off for stream output, Filter sets a priority cap -
messages with priority values greater than this filter value are
discarded. Default Priority sets the priority value for all messages
(until changed) and Priority is a temporary used to specify Priority
only until the next flush() , at which time Default Priority is
restored.</P>
<P><A NAME="block-352f64bc-5a67-4df0-bd47-dd18d15f3a77"></A>OutputStreams
and OutputChannels both provide member functions to change these
settings and I've provided manipulator functors that can be injected
into a stream or channel directly alongside other content much like
other Standard Library stream manipulators.</P>
<H5 CLASS="western"><A NAME="block-c3d667cb-dbb5-444a-ba38-0025b4a3dbe2"></A>
OutputStamp</H5>
<P><A NAME="block-b86c065a-4324-4675-a1a2-26f4fd36e563"></A>This is a
message prefixing base class used by OutputStreams and OutputChannels
to write an optional prefix to the front of the buffer before
forwarding to an OutputTarget.</P>
<P><A NAME="block-14c9aadb-0774-4c7d-93b7-12c59fc224e4"></A>The base
class defines the interface and provides a singleton instance which
is used as a default parameter by the constructors of both
OutputStream_t and OutputChannel_t.</P>
<PRE CLASS="western"><A NAME="block-e24fc026-3be8-44c3-a05b-5de8dec67bcf"></A>class OutputStamp
{
public:
    virtual int GetMaxLength() const { return 0; }
    virtual int GetLength() const { return 0; };
    virtual int WriteStamp( void * ptr_ = nullptr ) { return 0; }
    virtual void Lock() {}
    virtual void Unlock() {}
    static OutputStamp &amp; GetDummyStamp()
    {
        static OutputStamp instance;
        return instance;
    }
    OutputStamp() = default;
    virtual ~OutputStamp() = default;
};</PRE><P>
<A NAME="block-ba75924f-d479-44a6-91b5-a8595b3a83cf"></A>The Lock()
and Unlock() functions are called only by OutputChannels when running
in multithread mode: they call GetLength() and WriteStamp() in
succession and those two functions need to agree on the character
length of the next prefix write.</P>
<P><A NAME="block-ab974c29-d03d-4b21-9b3f-0f849fb58588"></A>I have
provided two example prefixing classes using this base class:
SystemTimeStamp and LineStamp: both of which are safe for concurrent
access of their singleton instances. The LineStamp is a very simple
example that variable length prefixing works. Both example classes
are templatised to work with different character types and provide
singleton instances by design only - OutputStamps can be different
object instances on each thread should you wish, it's all down to
your design and how and where you construct them.</P>
<H5 CLASS="western"><A NAME="block-c21dc9ad-4487-42a7-bd30-cb121ca6c492"></A>
OutputChannel &amp; ChannelBuffer</H5>
<P><A NAME="block-5eb84dd2-b49c-477e-a0ee-3971f00b7773"></A>OutputChannel
is a thread-safe class which attaches to one or more OutputStreams.
Message construction including any prefixing is handled locally until
such time as a flush() is triggered.</P>
<P><A NAME="block-5364a788-13eb-4485-a516-7f8ffd4c25ba"></A>The
OutputChannel class is similar to an OutputStream - it derives from
BasicStream via Stream or ConvertingStream:</P>
<PRE CLASS="western"><A NAME="block-089ac5b4-342a-45b5-a394-9fe3f7b89720"></A>template&lt; typename ELEM_, template&lt; typename &gt; typename STREAMBASE_ &gt;
<STRONG>class OutputChannel_t</STRONG> : public STREAMBASE_&lt; ELEM_<STRONG> &gt;</STRONG>
{
    ...
public:
<STRONG>OutputChannel_t( int channelID_, std::vector&lt; BasicStream_t&lt; type &gt; * &gt; const&amp; streams_, bool isMultiThreadChannel_ = true,  OutputStamp &amp; stamp_ = OutputStamp::GetDummyStamp(), StreamSettings * initSettings_ = &amp;GetDefaultChannelSettings() )</STRONG>
    ...
};</PRE><P>
<A NAME="block-1806eea4-cc77-465e-8ab2-6e3f9144bd70"></A>The
constructor requires a channel ID, a vector of pointers to one or
more OutputStream objects that the channel will write to, a
multi-thread usage flag, an optional OutputStamp instance and
optional non-default StreamSetting values.</P>
<P><A NAME="block-3b03372f-ce22-45fd-8810-5fdacc987135"></A>An
OutputChannel creates a ChannelBuffer. This buffer derives from
std::basic_stringbuf and has two specialisations to write to each
OutputStream the channel attaches to, with and without using mutexes.
The specialisation chosen depends upon the construction parameter
<EM>isMultiThreadChannel_</EM></P>
<P><A NAME="block-0c5b42b7-212a-4acd-a978-3422f9ad7cc8"></A>OutputChannels
also use a group of external arrays to control channel initialisation
and to hold the StreamSettings for each channel ID. This ensures that
existing channel settings are not reset when a new channel object is
constructed using an existing channel ID, e.g.: a new system thread
starting and initialising a global-scope thread_local OutputChannel.
Also present is a reference count of the number of channels attached
to each stream so that the stream's buffer is reset correctly once
the last channel has detached. Most of the work with these data
occurs in the OutputChannel's constructor and destructor, though the
OutputStream class destructor also clears its reference count to
avoid inadvertent access by a channel following its destruction.</P>
<P><A NAME="block-57a0e752-b6da-49bc-9f4a-5baa90785fa3"></A><EM>If
you do intend to create and destroy many streams and channels that
are shared by threads then it is advisable to destroy your channel
objects before you destroy the streams they are attached to - this is
because the shared stream array lookup table is accessed without the
mutex within the OutputChannel's sync() function. I felt this a
worthwhile caveat rather than make that array's elements atomic and
incur a performance hit - it's a fairly trivial tweak to change to
atomics but not one I felt was necessary.</EM></P>
<P>OutputStreams: <A HREF="#OutputStreams_Contents">Contents</A>
<A HREF="#OutputStreams_Design">Design</A> <A HREF="#OutputStreams_Profiling">Profiling</A></P>
<P><A HREF="http://www.mikebrown.co.uk/">mikebrown.co.uk homepage</A></P>
<HR>
<H2 CLASS="western"><A NAME="OutputStreams_Profiling"></A>OutputStreams
Performance Profiling</H2>
<H5 CLASS="western">Test Environments:</H5>
<OL>
	<LI><P>Windows 32-bit build with Microsoft cl.exe via CMake/Ninja
	with standard CMake release settings.</P>
</OL>
<P><EM>running on</EM>: Windows 10 Home Edition. Intel(R) Core(TM)
i7-1065G7 CPU @ 1.30GHz, 8Gb RAM, 512GB SSD</P>
<OL START=2>
	<LI><P>Linux(a) 32-bit build with G++ version 9.4.0 via CMake/Ninja
	with standard release settings</P>
</OL>
<P><EM>running on</EM>:&nbsp; Ubuntu 20.0 LTS 64bit. VMWare
Workstation 16 Player on Windows PC (from 1)</P>
<OL START=3>
	<LI><P>Linux(b) 32-bit build with G++ version 9.4.0 via CMake/Ninja
	with standard release settings</P>
</OL>
<P><EM>running on</EM>: Ubuntu 20.0 LTS 64bit Workstation. Intel(R)
Core(TM) i5-3230M CPU @ 2.60GHz, 8Gb RAM, 1TB HDD</P>
<OL START=4>
	<LI><P>Linux(c) ARM build with G++ 8.3.0 via CMake/Ninja with
	standard CMake release settings</P>
</OL>
<P><EM>running on:</EM> Raspberry Pi 4</P>
<H5 CLASS="western">Method:</H5>
<P>Started multiple threads using C++ '11 &lt;thread&gt; library and
timed using std::chrono::high_resolution_clock. Ran each set of
output command tests fifty times via a main thread loop, storing
results of each.</P>
<P>Worker threads for each command loop test:</P>
<P>Timing commenced when the last thread had initialised stack
locals. Each thread ran same code, sending identical text
requirements to the output method, incremented the total count and
looped until the total count reached the iteration count - at this
point they exited. The main thread read the end time following the
last join() and started the next test. Which thread did the most work
wasn't important - I was just looking to collect raw throughput
figures.</P>
<H5 CLASS="western">Common Test Parameters:</H5>
<TABLE WIDTH=418 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=360>
	<COL WIDTH=50>
	<TR>
		<TD WIDTH=360>
			<P>Number of Threads running each sample loop concurrently:</P>
		</TD>
		<TD WIDTH=50>
			<P>3</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=360>
			<P>Total number of output commands per sample:</P>
		</TD>
		<TD WIDTH=50>
			<P>50,000</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=360>
			<P>Samples gathered per Output Method per Test:</P>
		</TD>
		<TD WIDTH=50>
			<P>50</P>
		</TD>
	</TR>
</TABLE>
<H5 CLASS="western">Test 1:</H5>
<TABLE WIDTH=843 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=185>
	<COL WIDTH=650>
	<TR>
		<TD WIDTH=185>
			<P>Output Method and data sent:</P>
		</TD>
		<TD WIDTH=650>
			<P>PRINTF:<BR>printf( &quot;P: Thread %d writing to std::cout.
			Count = %d\n&quot;, threadNumber_, count );<BR><BR>OUTPUT_CHANNEL
			(to StreamStdOut&lt;char&gt; )<BR>channelOne &lt;&lt; &quot;C:
			Thread &quot; &lt;&lt; threadNumber_ &lt;&lt; &quot; writing to
			std::cout. Count = &quot; &lt;&lt; count &lt;&lt;
			std::endl;<BR><BR>STD_COUT<BR>std::cout &lt;&lt; &quot;S: Thread &quot;
			&lt;&lt; threadNumber_ &lt;&lt; &quot; writing to std::cout. Count
			= &quot; &lt;&lt; count &lt;&lt; std::endl;</P>
		</TD>
	</TR>
</TABLE>
<H3>Test 1 Results:</H3>
<OL>
	<LI><P>Windows x86</P>
</OL>
<TABLE WIDTH=364 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=57>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=57>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=57>
			<P>938 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>954 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>6,013 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=57>
			<P>969 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>1,093 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>6,439 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=57>
			<P>948 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>973 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>6,244 ms</P>
		</TD>
	</TR>
</TABLE>
<OL START=2>
	<LI><P>Linux(a) - x86 Virtual</P>
</OL>
<TABLE WIDTH=364 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=57>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=57>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=57>
			<P>328 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>309 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>239 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=57>
			<P>590 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>932 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>639 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=57>
			<P>460 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>557 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>502 ms</P>
		</TD>
	</TR>
</TABLE>
<OL START=3>
	<LI><P>Linux(b) - x86 Dedicated</P>
</OL>
<TABLE WIDTH=364 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=57>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=57>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=57>
			<P>348 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>352 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>356 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=57>
			<P>397 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>471 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>424 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=57>
			<P>359 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>419 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>388 ms</P>
		</TD>
	</TR>
</TABLE>
<OL START=4>
	<LI><P>Linux(c) - ARM</P>
</OL>
<TABLE WIDTH=367 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=60>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=60>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=60>
			<P>1,282 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>1,179 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>1,350 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=60>
			<P>1,680 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>1,377 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>1,754 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=60>
			<P>1,525 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>1,273 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>1,570 ms</P>
		</TD>
	</TR>
</TABLE>
<H2 CLASS="western">Test 2:</H2>
<TABLE WIDTH=1719 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=185>
	<COL WIDTH=1526>
	<TR>
		<TD WIDTH=185>
			<P>Output Method and data sent:</P>
		</TD>
		<TD WIDTH=1526>
			<P>PRINTF<BR>printf( &quot;P: String Literal 1: %s Floating point
			1: %f, Two integers %d %d, One hex integer %x. Second String
			Literal %s, a double %f\n&quot;, StringLit1, Float1, Int1, Int2,
			Int3, StringLit2, Double1 );<BR><BR>OUTPUT_CHANNEL (to
			StreamStdOut&lt;char&gt; )<BR>channelOne &lt;&lt; &quot;C: String
			Literal 1: &quot; &lt;&lt; StringLit1 &lt;&lt; &quot; Floating
			point 1: &quot; &lt;&lt; Float1 &lt;&lt; &quot; Two integers &quot;
			&lt;&lt; Int1 &lt;&lt; &quot; &quot; &lt;&lt; Int2 &lt;&lt; &quot;One
			hex integer &quot; &lt;&lt; std::hex &lt;&lt; Int3 &lt;&lt; &quot;
			Second String Literal &quot; &lt;&lt; StringLit2 &lt;&lt; &quot;,
			a double &quot; &lt;&lt; Double1 &lt;&lt;
			endl;<BR><BR>STD_COUT<BR>std::cout &lt;&lt; &quot;S: String
			Literal 1: &quot; &lt;&lt; StringLit1 &lt;&lt; &quot; Floating
			point 1: &quot; &lt;&lt; Float1 &lt;&lt; &quot; Two integers &quot;
			&lt;&lt; Int1 &lt;&lt; &quot; &quot; &lt;&lt; Int2 &lt;&lt; &quot;One
			hex integer &quot; &lt;&lt; std::hex &lt;&lt; Int3 &lt;&lt; &quot;
			Second String Literal &quot; &lt;&lt; StringLit2 &lt;&lt; &quot;,
			a double &quot; &lt;&lt; Double1 &lt;&lt; std::endl;</P>
		</TD>
	</TR>
</TABLE>
<H3>Test 2 Results:</H3>
<OL>
	<LI><P>Windows x86</P>
</OL>
<TABLE WIDTH=386 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=77>
	<COL WIDTH=147>
	<COL WIDTH=88>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=77>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=88>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,638 ms<BR>b) 1,639 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,504 ms<BR>b) 1,505 ms</P>
		</TD>
		<TD WIDTH=88>
			<P>a) 26,762 ms<BR>b) 26,979 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 2,235 ms<BR>b) 2,172 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 2,441 ms<BR>b) 2,235 ms</P>
		</TD>
		<TD WIDTH=88>
			<P>a) 34,186 ms<BR>b) 32,920 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,827 ms<BR>b) 1,959 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,712 ms<BR>b) 2,048 ms</P>
		</TD>
		<TD WIDTH=88>
			<P>a) 29,173 ms<BR>b) 31,158 ms</P>
		</TD>
	</TR>
</TABLE>
<OL START=2>
	<LI><P>Linux(a) - x86 Virtual</P>
</OL>
<TABLE WIDTH=384 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=77>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=77>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,145 ms<BR>b) 1,197 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 810 ms<BR>b) 848 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 1,216 ms<BR>b) 1,288 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,662 ms<BR>b) 1,587 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,438 ms<BR>b) 1391 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 1,860 ms<BR>b) 1,884 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,387ms<BR>b) 1,432 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,130 ms<BR>b) 1,085 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 1,521 ms<BR>b) 1,557 ms</P>
		</TD>
	</TR>
</TABLE>
<OL>
	<LI><P>Linux(b) - x86 Dedicated</P>
</OL>
<TABLE WIDTH=384 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=77>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=77>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,038 ms<BR>b) 992 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,011 ms<BR>b) 1,255 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 990 ms<BR>b) 985 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=77>
			<P>a)1,155 ms<BR>b) 1,168 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,249 ms<BR>b) 1,112 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 1,108 ms<BR>b) 1,121 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 1,097 ms<BR>b) 1,089 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 1,121 ms<BR>b) 1,112 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 1,042 ms<BR>b) 1,047 ms</P>
		</TD>
	</TR>
</TABLE>
<OL START=4>
	<LI><P>Linux(c) - ARM</P>
</OL>
<TABLE WIDTH=384 BORDER=0 CELLPADDING=2 CELLSPACING=0>
	<COL WIDTH=58>
	<COL WIDTH=77>
	<COL WIDTH=147>
	<COL WIDTH=86>
	<TR>
		<TD WIDTH=58>
			<P>Method:</P>
		</TD>
		<TD WIDTH=77>
			<P>PRINTF</P>
		</TD>
		<TD WIDTH=147>
			<P>OUTPUT_CHANNEL</P>
		</TD>
		<TD WIDTH=86>
			<P>STD_COUT</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Best</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 3,349 ms<BR>b) 3,257 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 2,752 ms<BR>b) 2,822 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 3,214 ms<BR>b) 3,303 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Worst</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 3,988 ms<BR>b) 4,057 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 3,137 ms<BR>b) 3,219 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 4,037 ms<BR>b) 4,006 ms</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=58>
			<P>Average:</P>
		</TD>
		<TD WIDTH=77>
			<P>a) 3,624 ms<BR>b) 3,551 ms</P>
		</TD>
		<TD WIDTH=147>
			<P>a) 2,903 ms<BR>b) 2,979 ms</P>
		</TD>
		<TD WIDTH=86>
			<P>a) 3,702 ms<BR>b) 3,632 ms</P>
		</TD>
	</TR>
</TABLE>
<H3>Observations:</H3>
<OL>
	<LI><P STYLE="margin-bottom: 0cm">Output to std::cout seems to be
	handled a lot more efficiently on Linux than Windows. Linux only
	very occasionally showed interleaving artifacts in output on the
	three targets I tried, suggesting that its internal synchronisition
	is more efficient. Perhaps it is using internal, per-thread buffers
	for streams much like my own system. At some point I will
	investigate the headers and disassembly output of both systems a
	little more closely. The timings suggest that Windows std::cout is
	hampered by locking for each input segment sent to the stream (e.g.
	every operator &lt;&lt; call), this is backed up by the interleaving
	noted in my blog. This does also mean, however, that if a thread
	crashes or is suspended during one of those calls at least you will
	still get all of the output to that point. I suspect Linux, like my
	own code, would risk losing whatever was already in the output
	buffer should a thread die. We also have to consider that
	internally, Windows timings also might be affected by converting the
	final char * string to a wchar_t sequence internally before sending
	to the console.</P>
	<LI><P STYLE="margin-bottom: 0cm">Streams catch and outperform
	variadic printf calls when we have more complex data to output. This
	is unsurprising given each formatting string sent to a variadic
	function must be parsed for content type and each item in the
	variadic list must have its string size computed before the length
	of the final output string is known. That single function call could
	contain many internal library function calls and small buffer
	allocations - efficiency will come down to exact library
	implementation and how the parsing of the formatting string and the
	buffering of items in the variadic list is actually handled. One for
	the library writers to comment on... As for my OutputStreams: they
	are helped by the efficiency of using a single write() both from the
	local thread buffer to the shared stream's buffer and from the
	shared stream's buffer through to std::cout. Buffer content and size
	is known and fixed at the point those transactions happen, so the
	mutex is locked and held for the minimum possible time.</P>
	<LI><P>OutputStreams perform especially well on a lightweight OS
	such as the default Raspberry Pi OS running on the Broadcom ARM
	quad-core.</P>
</OL>
<H3>Conclusion:</H3>
<P>OutputChannels appear to compare very&nbsp; favourably to raw
printfs in a multi-threaded environment. They are also almost as fast
as native Standard Library streams when writing to system consoles
but without falling victim to interleaving. This comparison looks to
become even more favorable the higher the number of hardware threads
due to further work being handled by local thread objects so less
contention on the target. This appears to be backed up by the
performance on the 4 core Linux machine (even a virtual one) and the
ARM when compared to the 2 core dedicated Linux machine.</P>
<H3>For future investigation:</H3>
<OL>
	<LI><P STYLE="margin-bottom: 0cm">Further research on all of the
	above</P>
	<LI><P>Profiling on writes to files using similar tests</P>
</OL>
<P>OutputStreams: <A HREF="#OutputStreams_Contents">Contents</A>
<A HREF="#OutputStreams_Design">Design</A> <A HREF="#OutputStreams_Profiling">Profiling</A></P>
<P><A HREF="http://www.mikebrown.co.uk/">mikebrown.co.uk homepage</A></P>
<HR>
<P><BR><BR>
</P>
</BODY>
</HTML>